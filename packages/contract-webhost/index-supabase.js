const express = require('express');
const path = require('path');
const ethers = require('ethers');
const { createClient } = require('@supabase/supabase-js');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// Initialize Supabase client
const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_ANON_KEY
);

// Serve static files from the 'public' directory
app.use(express.static(path.join(__dirname, 'public')));

// Serve the main page
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Set up Ethereum provider and contract
const setupEthereumWatcher = async () => {
  try {
    const provider = new ethers.providers.JsonRpcProvider(process.env.ETHEREUM_RPC_URL);
    const contractAddress = process.env.CONTRACT_ADDRESS;
    const contractABI = require('../hardhat/artifacts/contracts/YourContract.sol/YourContract.json').abi;
    const contract = new ethers.Contract(contractAddress, contractABI, provider);
    
    console.log('Ethereum contract watcher set up successfully');
    
    // Listen for DAOCreated events
    contract.on('DAOCreated', async (daoAddress, title, event) => {
      console.log('DAOCreated Event detected');
      
      try {
        const { data, error } = await supabase
          .from('daos')
          .insert([{
            name: title,
            description: `DAO created with address ${daoAddress}`,
            public_address: daoAddress,
            // You might want to add created_by if you have that information
          }]);

        if (error) throw error;
        console.log('DAO inserted successfully:', data);
      } catch (error) {
        console.error('Error inserting DAO:', error);
      }
    });
    
    // Listen for NeedCreated events
    contract.on('NeedCreated', async (needId, daoAddress, description, event) => {
      console.log('NeedCreated Event detected');
      
      try {
        // First, get the DAO id from the address
        const { data: daoData, error: daoError } = await supabase
          .from('daos')
          .select('id')
          .eq('public_address', daoAddress)
          .single();

        if (daoError) throw daoError;

        // Insert the need
        const { data, error } = await supabase
          .from('needs')
          .insert([{
            dao_id: daoData.id,
            description: description,
            // Note: embedding will be generated by a separate process/trigger
          }]);

        if (error) throw error;
        console.log('Need inserted successfully:', data);
      } catch (error) {
        console.error('Error inserting Need:', error);
      }
    });
    
    // Listen for PollinCreated events
    contract.on('PollinCreated', async (
      pollinId,
      daoWithNeed,
      daoWithOffering,
      needId,
      descriptionOfRelationship,
      confidence,
      event
    ) => {
      console.log('PollinCreated Event detected');
      
      try {
        // Get both DAOs' IDs from their addresses
        const { data: requestingDao, error: reqError } = await supabase
          .from('daos')
          .select('id')
          .eq('public_address', daoWithNeed)
          .single();

        const { data: fulfillingDao, error: fulfError } = await supabase
          .from('daos')
          .select('id')
          .eq('public_address', daoWithOffering)
          .single();

        if (reqError || fulfError) throw (reqError || fulfError);

        // Insert the pollen record
        const { data, error } = await supabase
          .from('pollen')
          .insert([{
            need_id: needId.toString(),
            requesting_dao_id: requestingDao.id,
            fulfilling_dao_id: fulfillingDao.id,
            collaboration_description: descriptionOfRelationship,
            confidence_score: parseFloat(confidence) / 100 // Assuming confidence comes in as a percentage
          }]);

        if (error) throw error;
        console.log('Pollen match inserted successfully:', data);
      } catch (error) {
        console.error('Error inserting Pollen match:', error);
      }
    });
    
  } catch (error) {
    console.error('Error setting up Ethereum watcher:', error);
  }
};

// Start the server with graceful shutdown
const server = app.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
  setupEthereumWatcher();
});

// Graceful shutdown handler
const shutdown = () => {
  console.log('\nShutting down gracefully...');
  server.close(() => {
    console.log('Server closed');
    process.exit(0);
  });
};

process.on('SIGINT', shutdown);
process.on('SIGTERM', shutdown);