{
  "language": "Solidity",
  "sources": {
    "contracts/PollinationStation.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract PollinationStation {\n    address public owner;\n\n    // DAO struct\n    struct DAO {\n        address daoAddress; // Unique identifier (DAO's address)\n        string title; // DAO title\n        string description; // DAO description\n        string socials; // Social media links or info\n        uint256[] needIds; // Array of Need IDs associated with this \n        uint256[] pollinIds; // Array of Pollin IDs associated with this DAO\n    }\n\n    // Need struct\n    struct Need {\n        uint256 needId; // Unique identifier\n        string description; // Need description\n        address dao; // DAO associated with this need\n    }\n\n    // Pollin struct (relationship between DAOs and a Need)\n    struct Pollin {\n        uint256 pollinId; // Unique identifier\n        address daoWithNeed; // DAO that has the need\n        address daoWithOffering; // DAO offering something for the need\n        uint256 needId; // The specific Need being addressed\n        string descriptionOfRelationship; // Description of the relationship\n        uint256 confidence; // Confidence score (0-100)\n    }\n\n    // Mappings to store data\n    mapping(address => DAO) public daos; // DAO address -> DAO struct\n    mapping(uint256 => Need) public needs; // Need ID -> Need struct\n    mapping(uint256 => Pollin) public pollins; // Pollin ID -> Pollin struct\n\n    // Counters for unique IDs\n    uint256 public needCount;\n    uint256 public pollinCount;\n    address[] public daoAddresses; // Array to keep track of all DAO addresses\n\n    // Events for off-chain indexing (e.g., The Graph)\n    event DAOCreated(address indexed daoAddress, string title, string description, string socials);\n    event NeedCreated(uint256 indexed needId, address indexed dao, string description);\n    event PollinCreated(\n        uint256 indexed pollinId,\n        address indexed daoWithNeed,\n        address indexed daoWithOffering,\n        uint256 needId,\n        string descriptionOfRelationship,\n        uint256 confidence\n    );\n\n    constructor(address _owner) {\n        owner = _owner;\n    }\n\n    // Function 1: Add a new DAO\n    function addDAO(string memory _title, string memory _description, string memory _socials) public {\n        address daoAddress = msg.sender;\n        require(daos[daoAddress].daoAddress == address(0), \"DAO already exists\");\n\n        daos[daoAddress] = DAO({\n            daoAddress: daoAddress,\n            title: _title,\n            description: _description,\n            socials: _socials,\n            needIds: new uint256[](0), // Initialize empty array\n            pollinIds: new uint256[](0) // Initialize empty array\n        });\n\n        daoAddresses.push(daoAddress); // Add the address to our tracking array\n        emit DAOCreated(daoAddress, _title, _description, _socials);\n    }\n\n    // Function 2: Add a Need associated with a DAO\n    function addNeed(string memory _description) public returns (uint256) {\n        address daoAddress = msg.sender;\n        require(daos[daoAddress].daoAddress != address(0), \"DAO does not exist\");\n\n        needCount++;\n        uint256 newNeedId = needCount;\n\n        needs[newNeedId] = Need({ needId: newNeedId, description: _description, dao: daoAddress });\n\n        // Link the Need to its DAO\n        daos[daoAddress].needIds.push(newNeedId);\n\n        emit NeedCreated(newNeedId, daoAddress, _description);\n        return newNeedId;\n    }\n\n    // Function 3: Add a Pollin (by AI agent)\n    function addPollin(\n        address _daoWithNeed,\n        address _daoWithOffering,\n        uint256 _needId,\n        string memory _descriptionOfRelationship,\n        uint256 _confidence\n    ) public returns (uint256) {\n        // Validate existence and ownership\n        require(daos[_daoWithNeed].daoAddress != address(0), \"DAO with need does not exist\");\n        require(daos[_daoWithOffering].daoAddress != address(0), \"DAO with offering does not exist\");\n        require(needs[_needId].needId != 0, \"Need does not exist\");\n        require(needs[_needId].dao == _daoWithNeed, \"Need does not belong to specified DAO\");\n        require(_confidence <= 100, \"Confidence must be 0-100\");\n\n        pollinCount++;\n        uint256 newPollinId = pollinCount;\n\n        pollins[newPollinId] = Pollin({\n            pollinId: newPollinId,\n            daoWithNeed: _daoWithNeed,\n            daoWithOffering: _daoWithOffering,\n            needId: _needId,\n            descriptionOfRelationship: _descriptionOfRelationship,\n            confidence: _confidence\n        });\n\n        emit PollinCreated(\n            newPollinId,\n            _daoWithNeed,\n            _daoWithOffering,\n            _needId,\n            _descriptionOfRelationship,\n            _confidence\n        );\n\n        daos[_daoWithNeed].pollinIds.push(newPollinId);\n        return newPollinId;\n    }\n\n    // Getter functions for front-end display\n    function getDAO(\n        address _daoAddress\n    )\n        public\n        view\n        returns (string memory title, string memory description, string memory socials, uint256[] memory needIds, uint256[] memory pollinIds)\n    {\n        DAO memory d = daos[_daoAddress];\n        require(d.daoAddress != address(0), \"DAO does not exist\");\n        return (d.title, d.description, d.socials, d.needIds, d.pollinIds);\n    }\n\n    function getNeed(uint256 _needId) public view returns (string memory description, address dao) {\n        Need memory n = needs[_needId];\n        require(n.needId != 0, \"Need does not exist\");\n        return (n.description, n.dao);\n    }\n\n    function getPollin(\n        uint256 _pollinId\n    )\n        public\n        view\n        returns (\n            address daoWithNeed,\n            address daoWithOffering,\n            uint256 needId,\n            string memory descriptionOfRelationship,\n            uint256 confidence\n        )\n    {\n        Pollin memory p = pollins[_pollinId];\n        require(p.pollinId != 0, \"Pollin does not exist\");\n        return (p.daoWithNeed, p.daoWithOffering, p.needId, p.descriptionOfRelationship, p.confidence);\n    }\n\n    // Function to get all DAOs\n    function getAllDAOs() public view returns (DAO[] memory) {\n        DAO[] memory allDAOs = new DAO[](daoAddresses.length);\n        \n        for (uint256 i = 0; i < daoAddresses.length; i++) {\n            allDAOs[i] = daos[daoAddresses[i]];\n        }\n        \n        return allDAOs;\n    }\n    \n    // Function to get the count of DAOs\n    function getDAOCount() public view returns (uint256) {\n        return daoAddresses.length;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}